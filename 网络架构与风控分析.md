# Antigravity Tools 网络架构与风控风险分析

## 一、网络流量架构分析

### 1.1 当前架构:集中式单节点

根据代码分析,**默认情况下所有账号的流量都走同一个 IP 节点**:

```
使用者客户端
    ↓
你的反代服务器 (127.0.0.1:8045 或 0.0.0.0:8045)
    ↓
[可选] 上游代理 (upstream_proxy)
    ↓
Google API (googleapis.com)
```

#### **关键配置**

**1. 本地监听地址** (`proxy.allow_lan_access`)
```rust
// src-tauri/src/proxy/config.rs
pub fn get_bind_address(&self) -> &str {
    if self.allow_lan_access {
        "0.0.0.0"  // 允许局域网访问
    } else {
        "127.0.0.1"  // 仅本机访问 (默认)
    }
}
```

**2. 上游代理配置** (`proxy.upstream_proxy`)
```rust
pub struct UpstreamProxyConfig {
    pub enabled: bool,
    pub url: String,  // 支持 http://, https://, socks5://
}
```

### 1.2 流量路径详解

#### **场景 A: 本地使用 (默认)**
```
你的电脑 (127.0.0.1)
  ├─ Claude Code CLI
  ├─ Cherry Studio
  └─ Python 脚本
      ↓
Antigravity 反代服务 (127.0.0.1:8045)
  └─ 账号池 (10 个 Google 账号)
      ↓
你的家庭/公司网络出口 IP (单一 IP)
      ↓
Google API
```

**特点**:
- ✅ 所有账号共享同一个出口 IP
- ✅ 简单,无需额外配置
- ⚠️ 存在 IP 关联风险

#### **场景 B: 局域网共享**
```
局域网内多台设备
  ├─ 设备 A (192.168.1.100)
  ├─ 设备 B (192.168.1.101)
  └─ 设备 C (192.168.1.102)
      ↓
你的服务器 (192.168.1.50:8045, allow_lan_access=true)
  └─ 账号池 (10 个 Google 账号)
      ↓
你的网络出口 IP (单一 IP)
      ↓
Google API
```

**特点**:
- ✅ 多设备共享账号池
- ✅ 统一管理
- ⚠️ 所有设备仍共享同一出口 IP

#### **场景 C: 上游代理 (分布式)**
```
Antigravity 反代服务
  └─ 账号池 (10 个 Google 账号)
      ↓
上游代理池 (upstream_proxy)
  ├─ 代理 1 (IP: 1.2.3.4)
  ├─ 代理 2 (IP: 5.6.7.8)
  └─ 代理 3 (IP: 9.10.11.12)
      ↓
Google API
```

**配置示例**:
```json
{
  "proxy": {
    "upstream_proxy": {
      "enabled": true,
      "url": "http://proxy.example.com:8080"
    }
  }
}
```

**特点**:
- ✅ 可以实现 IP 分布式
- ✅ 降低单 IP 风险
- ⚠️ 需要自行搭建/购买代理服务
- ⚠️ **当前实现是全局代理,所有账号共享同一个上游代理**

### 1.3 当前架构的局限性

**问题**: 代码中的 `upstream_proxy` 是**全局配置**,所有账号共享:

```rust
// src-tauri/src/utils/http.rs
fn create_base_client(timeout_secs: u64) -> Client {
    let mut builder = Client::builder()
        .timeout(std::time::Duration::from_secs(timeout_secs));
    
    if let Ok(config) = load_app_config() {
        let proxy_config = config.proxy.upstream_proxy;  // 全局配置
        if proxy_config.enabled && !proxy_config.url.is_empty() {
            match Proxy::all(&proxy_config.url) {  // 所有请求使用同一代理
                Ok(proxy) => {
                    builder = builder.proxy(proxy);
                }
                Err(e) => {
                    tracing::error!("invalid_proxy_url: {}, error: {}", proxy_config.url, e);
                }
            }
        }
    }
    
    builder.build().unwrap_or_else(|_| Client::new())
}
```

**结论**: 
- ❌ **无法为每个账号配置独立的代理**
- ❌ **无法实现真正的分布式 IP**
- ✅ 可以通过外部代理池 + 轮询实现,但需要额外开发

---

## 二、风控风险分析

### 2.1 管理者角度 (中转服务提供者)

#### **风险等级: 🟡 中等**

**主要风险**:

1. **IP 关联风险**
   - **问题**: 多个 Google 账号从同一 IP 发起大量请求
   - **表现**: Google 可能检测到异常流量模式
   - **后果**: 
     - 触发 429 限流 (短期)
     - 账号被标记为"可疑活动" (中期)
     - 严重时可能导致账号封禁 (长期)

2. **流量特征风险**
   - **问题**: 所有请求的 User-Agent、TLS 指纹相同
   - **代码证据**:
   ```rust
   // src-tauri/src/constants.rs
   pub static USER_AGENT: LazyLock<String> = LazyLock::new(|| {
       // 所有请求使用相同的 User-Agent
       format!("antigravity/{}", get_version())
   });
   ```
   - **后果**: 容易被识别为自动化工具

3. **设备指纹风险**
   - **好消息**: 项目已实现设备指纹隔离
   - **代码证据**:
   ```rust
   // src-tauri/src/models/account.rs
   pub struct Account {
       pub device_profile: Option<DeviceProfile>,  // 每个账号可绑定独立设备指纹
       pub device_history: Vec<DeviceProfileVersion>,
   }
   
   pub struct DeviceProfile {
       pub machine_id: String,
       pub mac_machine_id: String,
       pub dev_device_id: String,
       pub sqm_id: String,
   }
   ```
   - **作用**: 每个账号可以模拟不同的设备,降低关联风险

#### **风险缓解措施**:

✅ **已实现**:
1. **设备指纹隔离**: 每个账号可绑定独立的 `device_profile`
2. **智能调度**: 避免短时间内频繁切换账号
3. **限流保护**: 自动检测 429 错误并退避

⚠️ **建议增强**:
1. **IP 池化**: 
   - 为每个账号配置独立的代理
   - 或使用住宅代理池轮换 IP
   
2. **User-Agent 随机化**:
   ```rust
   // 建议修改
   pub fn get_user_agent_for_account(account_id: &str) -> String {
       // 根据账号生成不同的 UA
       format!("antigravity/{} (Account-{})", get_version(), account_id)
   }
   ```

3. **请求频率控制**:
   - 单账号每分钟请求数限制
   - 全局 QPS 限制

### 2.2 使用者角度 (API 调用方)

#### **风险等级: 🟢 低**

**使用者视角**:
```
使用者 (客户端)
    ↓
你的反代服务 (http://your-server:8045)
    ↓
[黑盒] 账号池 + 调度逻辑
    ↓
Google API
```

**风险分析**:

1. **IP 暴露风险**: ❌ **无**
   - 使用者的真实 IP 不会暴露给 Google
   - 所有请求都从你的服务器 IP 发出

2. **账号关联风险**: ❌ **无**
   - 使用者不知道具体使用了哪个 Google 账号
   - 账号切换对使用者完全透明

3. **数据隐私风险**: ⚠️ **中等**
   - **问题**: 所有请求内容都经过你的服务器
   - **建议**: 
     - 明确告知使用者数据流向
     - 不记录敏感请求内容
     - 启用 HTTPS (如果对外提供服务)

4. **服务稳定性风险**: 🟡 **中等**
   - **问题**: 如果你的服务器被封禁,所有使用者都会受影响
   - **建议**: 
     - 提供多个备用节点
     - 实现故障转移机制

---

## 三、Google 风控机制分析

### 3.1 Google 的检测维度

根据行业经验和代码分析,Google 主要从以下维度检测异常:

1. **IP 维度**
   - 单 IP 短时间内大量请求
   - IP 地理位置与账号注册地不符
   - 数据中心 IP / VPS IP (风险高于住宅 IP)

2. **账号维度**
   - 账号登录地点频繁变化
   - 账号行为模式异常 (如 24 小时不间断调用)
   - 多账号行为高度相似

3. **设备维度**
   - 设备指纹 (machine_id, device_id)
   - User-Agent 与设备不匹配
   - TLS 指纹异常

4. **流量维度**
   - 请求频率异常
   - 请求模式机械化 (如固定间隔)
   - API 调用量远超正常用户

### 3.2 Antigravity 的对抗措施

#### ✅ **已实现**:

1. **设备指纹隔离**
   ```rust
   // 每个账号可绑定独立设备指纹
   pub fn bind_device_profile(account_id: &str, mode: &str) -> Result<DeviceProfile, String>
   ```

2. **智能调度算法**
   ```rust
   // 优先级排序,避免频繁切换
   tokens_snapshot.sort_by(|a, b| {
       // 订阅等级 > 配额 > 健康分数
   });
   ```

3. **限流保护**
   ```rust
   // 自动检测 429 并退避
   if is_rate_limited {
       self.rate_limit_tracker.record_rate_limit(&account_id, model, 60);
   }
   ```

4. **配额保护**
   ```rust
   // 低配额账号自动保护
   if percentage <= threshold {
       account.protected_models.insert(model_name);
   }
   ```

#### ⚠️ **缺失的防护**:

1. **IP 池化**: 无法为每个账号分配独立 IP
2. **User-Agent 多样化**: 所有请求使用相同 UA
3. **请求时间随机化**: 无主动引入随机延迟
4. **行为模式模拟**: 无模拟人类使用模式

---

## 四、风险等级评估

### 4.1 不同使用场景的风险

| 场景 | 账号数 | 日请求量 | IP 策略 | 风险等级 | 建议 |
|------|--------|----------|---------|----------|------|
| **个人使用** | 1-3 | < 1000 | 单 IP | 🟢 低 | 正常使用即可 |
| **小团队** | 3-10 | 1000-5000 | 单 IP | 🟡 中 | 建议启用设备指纹隔离 |
| **商业服务** | 10-50 | 5000-20000 | 单 IP | 🔴 高 | **必须**使用 IP 池 + 设备隔离 |
| **大规模部署** | 50+ | 20000+ | 单 IP | 🔴 极高 | **禁止**,必须分布式架构 |

### 4.2 触发风控的典型阈值 (经验值)

| 指标 | 安全阈值 | 警告阈值 | 危险阈值 |
|------|----------|----------|----------|
| **单 IP 日请求量** | < 5000 | 5000-10000 | > 10000 |
| **单账号 QPS** | < 1 | 1-3 | > 3 |
| **账号切换频率** | < 10次/小时 | 10-30次/小时 | > 30次/小时 |
| **同 IP 账号数** | < 5 | 5-10 | > 10 |

---

## 五、最佳实践建议

### 5.1 低风险配置 (个人/小团队)

```json
{
  "proxy": {
    "enabled": true,
    "allow_lan_access": false,  // 仅本机访问
    "port": 8045,
    "scheduling": {
      "mode": "CacheFirst",  // 启用会话粘性,减少切换
      "enable_sticky": true
    }
  },
  "quota_protection": {
    "enabled": true,
    "threshold_percentage": 20  // 提高阈值,减少切换
  }
}
```

**操作建议**:
1. 启用设备指纹隔离 (每个账号绑定独立 device_profile)
2. 控制请求频率 (避免短时间大量请求)
3. 定期轮换账号 (避免单账号长期高负载)

### 5.2 中等风险配置 (商业服务)

```json
{
  "proxy": {
    "enabled": true,
    "allow_lan_access": true,  // 允许局域网访问
    "upstream_proxy": {
      "enabled": true,
      "url": "http://proxy-pool.example.com:8080"  // 使用代理池
    },
    "scheduling": {
      "mode": "Balance"  // 平衡模式
    }
  }
}
```

**操作建议**:
1. **必须**使用住宅代理池
2. **必须**为每个账号绑定设备指纹
3. 实现请求频率限制 (单账号 QPS < 1)
4. 监控 429 错误率,及时调整策略

### 5.3 高风险场景 (大规模部署)

**架构升级建议**:

```
使用者
    ↓
负载均衡器
    ↓
多个 Antigravity 实例
  ├─ 实例 1 (账号 1-10, 代理池 A)
  ├─ 实例 2 (账号 11-20, 代理池 B)
  └─ 实例 3 (账号 21-30, 代理池 C)
      ↓
Google API
```

**代码改造建议**:

1. **账号级代理配置**:
```rust
// 建议新增
pub struct Account {
    pub proxy_config: Option<UpstreamProxyConfig>,  // 账号独立代理
}
```

2. **动态代理选择**:
```rust
async fn get_proxy_for_account(account_id: &str) -> Option<Proxy> {
    // 从代理池中为账号分配 IP
    let proxy_url = PROXY_POOL.get_proxy_for_account(account_id);
    Proxy::all(&proxy_url).ok()
}
```

3. **请求频率控制**:
```rust
pub struct RateLimiter {
    account_limits: DashMap<String, TokenBucket>,  // 每账号独立限流
}
```

---

## 六、总结与建议

### 6.1 当前架构总结

**优点**:
- ✅ 设备指纹隔离 (降低账号关联风险)
- ✅ 智能调度算法 (优化账号使用)
- ✅ 限流保护 (自动退避)
- ✅ 配额保护 (避免账号耗尽)

**缺点**:
- ❌ 所有账号共享单一 IP (高风险)
- ❌ 无法为每个账号配置独立代理
- ❌ User-Agent 固定 (易被识别)
- ❌ 无请求频率限制

### 6.2 风险等级判断

**你的风险等级取决于**:
1. **账号数量**: 越多风险越高
2. **请求量**: 越大风险越高
3. **IP 策略**: 单 IP 风险高,IP 池风险低
4. **使用场景**: 个人使用低风险,商业服务高风险

### 6.3 核心建议

**立即可做**:
1. ✅ 为每个账号绑定独立设备指纹
2. ✅ 启用配额保护,阈值设为 20%
3. ✅ 使用 `CacheFirst` 模式减少切换

**短期优化**:
1. 🔧 接入住宅代理池 (通过 `upstream_proxy`)
2. 🔧 控制全局 QPS (< 10 QPS)
3. 🔧 监控 429 错误率

**长期改造** (如果需要大规模部署):
1. 🏗️ 实现账号级代理配置
2. 🏗️ User-Agent 随机化
3. 🏗️ 请求时间随机化
4. 🏗️ 分布式架构 (多实例 + 负载均衡)

---

## 附录: 风控检测自查清单

### A. IP 维度
- [ ] 是否使用住宅 IP? (数据中心 IP 风险高)
- [ ] 单 IP 日请求量是否 < 5000?
- [ ] 是否有 IP 轮换机制?

### B. 账号维度
- [ ] 每个账号是否绑定独立设备指纹?
- [ ] 账号登录地点是否稳定?
- [ ] 是否避免 24 小时不间断调用?

### C. 流量维度
- [ ] 单账号 QPS 是否 < 1?
- [ ] 是否有请求频率限制?
- [ ] 是否引入随机延迟?

### D. 设备维度
- [ ] User-Agent 是否多样化?
- [ ] TLS 指纹是否正常?
- [ ] 设备信息是否与账号匹配?

**评分标准**:
- 12-16 项 ✅: 🟢 低风险
- 8-11 项 ✅: 🟡 中等风险
- 4-7 项 ✅: 🟠 较高风险
- 0-3 项 ✅: 🔴 高风险

---

**文档版本**: 1.0  
**最后更新**: 2026-01-30  
**作者**: Antigravity Security Analysis
